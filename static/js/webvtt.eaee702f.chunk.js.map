{"version":3,"sources":["E:/xampp/7.4.16/htdocs/SepehrApi-Webapp-ReactJS/node_modules/fluid-player/vendor/webvtt.js"],"names":["WebVTTCueTimingsAndSettingsParser","line","errorHandler","SPACE","NOSPACE","pos","err","message","skip","pattern","undefined","test","collect","str","timestamp","val1","val2","val3","val4","units","length","parseInt","this","parse","cue","previousCueStart","startTime","endTime","input","settings","split","seen","i","index","indexOf","setting","slice","value","push","direction","snapToLines","linePosition","textPosition","size","alignValues","join","alignment","parseSettings","substring","parseTimestamp","ts","WebVTTCueTextParser","mode","nextToken","state","result","buffer","classes","c","filter","item","cueStart","cueEnd","children","current","timestamps","attach","token","type","name","parent","inScope","node","WebVTTParser","Date","now","linePos","lines","alreadyCollected","cues","errors","col","lineLength","signature","bom","signature_length","id","pauseOnExit","text","tree","parseTimings","timings","cuetextparser","sort","a","b","time"],"mappings":"wHAAA,OAKA,IAoKIA,EAAoC,SAASC,EAAMC,GACrD,IAAIC,EAAQ,eACRC,EAAU,gBAEVC,GADAJ,EAAOA,EACD,GACNK,EAAM,SAASC,GACbL,EAAaK,EAASF,EAAI,IAGhC,SAASG,EAAKC,GACZ,UACeC,GAAbT,EAAKI,IACLI,EAAQE,KAAKV,EAAKI,KAElBA,IAGJ,SAASO,EAAQH,GAEf,IADA,IAAII,EAAM,QAEKH,GAAbT,EAAKI,IACLI,EAAQE,KAAKV,EAAKI,KAElBQ,GAAOZ,EAAKI,GACZA,IAEF,OAAOQ,EAGT,SAASC,IACP,IACIC,EACAC,EACAC,EACAC,EAJAC,EAAQ,UAMZ,QAAgBT,GAAbT,EAAKI,GAKR,GAAI,KAAKM,KAAKV,EAAKI,IAUnB,KALAU,EAAOH,EAAQ,OACPQ,OAAS,GAAKC,SAASN,EAAM,IAAM,MACzCI,EAAQ,SAGM,KAAblB,EAAKI,GAOR,GAHAA,IAGkB,IADlBW,EAAOJ,EAAQ,OACPQ,OAAR,CAKA,GAAY,SAATD,GAAiC,KAAblB,EAAKI,GAAa,CACvC,GAAgB,KAAbJ,EAAKI,GAEN,YADAC,EAAI,mDAKN,GAFAD,IAEkB,IADlBY,EAAOL,EAAQ,OACPQ,OAEN,YADAd,EAAI,oCAINW,EAAOD,EACPA,EAAOD,EACPA,EAAO,IAGT,GAAgB,KAAbd,EAAKI,GAOR,GAHAA,IAGkB,IADlBa,EAAON,EAAQ,OACPQ,OAKR,GAAGC,SAASL,EAAM,IAAM,GACtBV,EAAI,6CADN,CAIA,KAAGe,SAASJ,EAAM,IAAM,IAIxB,OAA4B,GAArBI,SAASN,EAAM,IAAW,GAA0B,GAArBM,SAASL,EAAM,IAAWK,SAASJ,EAAM,IAAMI,SAASH,EAAM,IAAM,IAHxGZ,EAAI,8CATJA,EAAI,oDAPJA,EAAI,0CAtBJA,EAAI,oCAPJA,EAAI,sCAVJA,EAAI,gEALJA,EAAI,uBAwJRgB,KAAKC,MAAQ,SAASC,EAAKC,GAGzB,GAFAjB,EAAKL,GACLqB,EAAIE,UAAYZ,SACIJ,GAAjBc,EAAIE,UAWP,GARGF,EAAIE,UAAYD,GACjBnB,EAAI,oFAEHF,EAAQO,KAAKV,EAAKI,KACnBC,EAAI,wDAENE,EAAKL,GAEW,KAAbF,EAAKI,GAKR,GADAA,IACgB,KAAbJ,EAAKI,GAKR,GADAA,IACgB,KAAbJ,EAAKI,IAUR,GANAA,IACGD,EAAQO,KAAKV,EAAKI,KACnBC,EAAI,wDAENE,EAAKL,GACLqB,EAAIG,QAAUb,SACIJ,GAAfc,EAAIG,QAYP,OATGH,EAAIG,SAAWH,EAAIE,WACpBpB,EAAI,sDAGHF,EAAQO,KAAKV,EAAKI,MACE,EAEvBG,EAAKL,GAjIP,SAAuByB,EAAOJ,GAG5B,IAFA,IAAIK,EAAWD,EAAME,MAAM3B,GACvB4B,EAAO,GACHC,EAAE,EAAGA,EAAIH,EAAST,OAAQY,IAChC,GAAkB,IAAfH,EAASG,GAAZ,CAGA,IAAIC,EAAQJ,EAASG,GAAGE,QAAQ,KAC5BC,EAAUN,EAASG,GAAGI,MAAM,EAAGH,GAQnC,GAPII,MAAQR,EAASG,GAAGI,MAAMH,EAAQ,IAET,GAA1BF,EAAKG,QAAQC,IACd7B,EAAI,sBAENyB,EAAKO,KAAKH,GAEE,IAATE,MAED,YADA/B,EAAI,iCAIN,GAAc,YAAX6B,EAAuB,CACxB,GAAY,MAATE,OAA0B,MAATA,MAAe,CACjC/B,EAAI,sDACJ,SAEFkB,EAAIe,UAAYF,WACX,GAAc,QAAXF,EAAmB,CAC3B,IAAI,KAAKxB,KAAK0B,OAAQ,CACpB/B,EAAI,+CACJ,SAEF,IAA6B,GAA1B+B,MAAMH,QAAQ,IAAK,GAAU,CAC9B5B,EAAI,iDACJ,SAEF,IAA0B,GAAvB+B,MAAMH,QAAQ,MAAcG,MAAMH,QAAQ,MAAQG,MAAMjB,OAAO,EAAG,CACnEd,EAAI,+CACJ,SAEF,GAAe,KAAZ+B,MAAM,IAAsC,KAAzBA,MAAMA,MAAMjB,OAAO,GAAW,CAClDd,EAAI,kDACJ,SAEF,GAA4B,KAAzB+B,MAAMA,MAAMjB,OAAO,GAAW,CAC/B,GAAGC,SAASgB,MAAO,IAAM,IAAK,CAC5B/B,EAAI,kCACJ,SAEFkB,EAAIgB,aAAc,EAEpBhB,EAAIiB,aAAepB,SAASgB,MAAO,SAC9B,GAAc,YAAXF,EAAuB,CAC/B,GAA4B,KAAzBE,MAAMA,MAAMjB,OAAO,GAAW,CAC/Bd,EAAI,uCACJ,SAEF,GAAGe,SAASgB,MAAO,IAAM,IAAK,CAC5B/B,EAAI,yBACJ,SAEFkB,EAAIkB,aAAerB,SAASgB,MAAO,SAC9B,GAAc,QAAXF,EAAmB,CAC3B,GAA4B,KAAzBE,MAAMA,MAAMjB,OAAO,GAAW,CAC/Bd,EAAI,8BACJ,SAEF,GAAGe,SAASgB,MAAO,IAAM,IAAK,CAC5B/B,EAAI,yBACJ,SAEFkB,EAAImB,KAAOtB,SAASgB,MAAO,SACtB,GAAc,SAAXF,EAAoB,CAC5B,IAAIS,EAAc,CAAC,QAAS,SAAU,MAAO,OAAQ,SACrD,IAAkC,GAA/BA,EAAYV,QAAQG,OAAc,CACnC/B,EAAI,uCAAyCsC,EAAYC,KAAK,MAAQ,KACtE,SAEFrB,EAAIsB,UAAYT,WAEhB/B,EAAI,qBAkDRyC,CAAc9C,EAAK+C,UAAU3C,GAAMmB,IAC5B,OArBLlB,EAAI,4CALJA,EAAI,4CALJA,EAAI,wCAiCRgB,KAAK2B,eAAiB,WACpB,IAAIC,EAAKpC,IACT,QAAgBJ,GAAbT,EAAKI,GAIR,OAAO6C,EAHL5C,EAAI,kDAON6C,EAAsB,SAASlD,EAAMC,EAAckD,GACjDnD,EAAOA,EAAX,IACII,EAAM,EACNC,EAAM,SAASC,GACF,YAAR6C,GAEHlD,EAAaK,EAASF,EAAI,IA+FhC,SAASgD,IAKP,IAJA,IAAIC,EAAQ,OACRC,EAAS,GACTC,EAAS,GACTC,EAAU,QACO/C,GAAfT,EAAKI,EAAI,IAA0B,GAAPA,GAAU,CAC1C,IAAIqD,EAAIzD,EAAKI,GACb,GAAY,QAATiD,EACD,GAAQ,KAALI,EACDF,EAASE,EACTJ,EAAQ,cACH,GAAQ,KAALI,GAAsB,IAAVH,EACpBD,EAAQ,UACH,IAAQ,KAALI,QAAiBhD,GAALgD,EACpB,MAAO,CAAC,OAAQH,GAEhBA,GAAUG,OAEP,GAAY,UAATJ,EACR,GAAQ,KAALI,EACDpD,EAAI,qBACJiD,GAAUC,EACVA,EAASE,OACJ,GAAG,eAAe/C,KAAK+C,GAC5BF,GAAUE,OACL,GAAQ,KAALA,EACK,QAAVF,EACDD,GAAU,IACQ,OAAVC,EACRD,GAAU,IACQ,OAAVC,EACRD,GAAU,IACQ,QAAVC,EACRD,GAAU,SACQ,QAAVC,EACRD,GAAU,SACQ,SAAVC,EACRD,GAAU,QAEVjD,EAAI,qBACJiD,GAAUC,EAAS,KAErBF,EAAQ,WACH,IAAQ,KAALI,QAAiBhD,GAALgD,EAGpB,OAFApD,EAAI,qBAEG,CAAC,OADRiD,GAAUC,GAGVlD,EAAI,qBACJiD,GAAUC,EAASE,EACnBJ,EAAQ,YAEL,GAAY,OAATA,EACR,GAAQ,MAALI,GAAkB,MAALA,GAAkB,MAALA,GAAkB,KAALA,EACxCJ,EAAQ,4BACH,GAAQ,KAALI,EACRJ,EAAQ,uBACH,GAAQ,KAALI,EACRJ,EAAQ,eACH,GAAG,KAAK3C,KAAK+C,GAClBH,EAASG,EACTJ,EAAQ,oBACH,IAAQ,KAALI,QAAiBhD,GAALgD,EAIpB,MAHQ,KAALA,GACDrD,IAEK,CAAC,YAAa,GAAI,GAAI,IAE7BkD,EAASG,EACTJ,EAAQ,iBAEL,GAAY,aAATA,EACR,GAAQ,MAALI,GAAkB,MAALA,GAAkB,KAALA,EAC3BJ,EAAQ,4BACH,GAAQ,MAALI,EACRF,EAASE,EACTJ,EAAQ,4BACH,GAAQ,KAALI,EACRJ,EAAQ,sBACH,IAAQ,KAALI,QAAiBhD,GAALgD,EAIpB,MAHQ,KAALA,GACDrD,IAEK,CAAC,YAAakD,EAAQ,GAAI,IAEjCA,GAAUG,OAEP,GAAY,mBAATJ,EACR,GAAQ,MAALI,GAAkB,MAALA,GAAkB,KAALA,EAC3BD,EAAQnB,KAAKkB,GACbA,EAAS,GACTF,EAAQ,4BACH,GAAQ,MAALI,EACRD,EAAQnB,KAAKkB,GACbA,EAASE,EACTJ,EAAQ,4BACH,GAAQ,KAALI,EACRD,EAAQnB,KAAKkB,GACbA,EAAS,OACJ,IAAQ,KAALE,QAAiBhD,GAALgD,EAKpB,MAJQ,KAALA,GACDrD,IAEFoD,EAAQnB,KAAKkB,GACN,CAAC,YAAaD,EAAQE,EAAS,IAEtCD,GAAUE,OAEP,GAAY,wBAATJ,EAAiC,CACzC,GAAQ,KAALI,QAAiBhD,GAALgD,EAKb,MAJQ,KAALA,GACDrD,IAGK,CAAC,YAAakD,EAAQE,EAD7BD,EAASA,EAAO1B,MAAM,qBAAqB6B,QAAO,SAASC,GAAQ,GAAGA,EAAM,OAAO,KAAQf,KAAK,MAGhGW,GAASE,OAEN,GAAY,WAATJ,EAAoB,CAC5B,GAAQ,KAALI,QAAiBhD,GAALgD,EAIb,MAHQ,KAALA,GACDrD,IAEK,CAAC,UAAWkD,GAEnBA,GAAUG,OAEP,GAAY,iBAATJ,EAA0B,CAClC,GAAQ,KAALI,QAAiBhD,GAALgD,EAIb,MAHQ,KAALA,GACDrD,IAEK,CAAC,YAAakD,GAErBA,GAAUG,OAGZpD,EAAI,kBAGND,KAxOJiB,KAAKC,MAAQ,SAASsC,EAAUC,GAC9B,IAAIP,EAAS,CAACQ,SAAS,IACnBC,EAAUT,EACVU,EAAa,GAEjB,SAASC,EAAOC,GACdH,EAAQD,SAASzB,KAAK,CAAC8B,KAAK,SAAUC,KAAKF,EAAM,GAAIV,QAAQU,EAAM,GAAIJ,SAAS,GAAIO,OAAON,IAC3FA,EAAUA,EAAQD,SAASC,EAAQD,SAAS3C,OAAO,GAErD,SAASmD,EAAQF,GAEf,IADA,IAAIG,EAAOR,EACLQ,GAAM,CACV,GAAGA,EAAKH,MAAQA,EACd,OAAO,EACTG,EAAOA,EAAKF,QAKhB,UAAmB5D,GAAbT,EAAKI,IAAmB,CAC5B,IAAI8D,EAAQd,IACZ,GAAe,QAAZc,EAAM,GACPH,EAAQD,SAASzB,KAAK,CAAC8B,KAAK,OAAQ/B,MAAM8B,EAAM,GAAIG,OAAON,SACtD,GAAe,aAAZG,EAAM,GAAmB,CACtB,YAARf,GACD9C,EAAI,iDACN,IAAI+D,EAAOF,EAAM,GACN,KAARE,GAAuB,QAARA,GAA8B,IAAZF,EAAM,IACxC7D,EAAI,+CAGI,KAAR+D,GACQ,KAARA,GACQ,KAARA,GACQ,KAARA,GACQ,QAARA,GAGgB,MAARA,GAAgC,QAAhBL,EAAQK,KADhCH,EAAOC,GAGS,KAARE,GACLE,EAAQ,MACTjE,EAAI,uCAEN4D,EAAOC,GACPH,EAAQ3B,MAAQ8B,EAAM,GAClBA,EAAM,IACR7D,EAAI,gCAEU,QAAR+D,GACRH,EAAOC,GACPH,EAAQ3B,MAAQ8B,EAAM,IAEtB7D,EAAI,6BAED,GAAe,WAAZ6D,EAAM,GACH,YAARf,GACD9C,EAAI,+CAEH6D,EAAM,IAAMH,EAAQK,KACrBL,EAAUA,EAAQM,OACE,QAAZH,EAAM,IAAgC,MAAhBH,EAAQK,KACtCL,EAAUA,EAAQM,OAAOA,OAEzBhE,EAAI,2BAED,GAAe,aAAZ6D,EAAM,GAAmB,CACtB,YAARf,GACD9C,EAAI,gDACN,IACIQ,EADU,IAAId,EAAkCmE,EAAM,GAAI7D,GACtC2C,sBACRvC,GAAbI,KACEA,GAAa+C,GAAY/C,GAAagD,IACvCxD,EAAI,gEAEH2D,EAAW7C,OAAS,GAAK6C,EAAWA,EAAW7C,OAAO,IAAMN,GAC7DR,EAAI,0DAEN0D,EAAQD,SAASzB,KAAK,CAAC8B,KAAK,YAAa/B,MAAMvB,EAAWwD,OAAON,IACjEC,EAAW3B,KAAKxB,KAItB,KAAMkD,EAAQM,QACO,KAAhBN,EAAQK,MACT/D,EAAI,6BAEN0D,EAAUA,EAAQM,OAEpB,OAAOf,IA2LIkB,UAxrBI,WACjBnD,KAAKC,MAAQ,SAASK,EAAOwB,GAE3B,IACI1B,EAAYgD,KAAKC,MACjBC,EAAU,EACVC,EAAQjD,EAAME,MAHJ,cAIVgD,GAAmB,EACnBC,EAAO,GACPC,EAAS,GACb,SAAS1E,EAAIC,EAAS0E,GACpBD,EAAO1C,KAAK,CAAC/B,QAAQA,EAASN,KAAK2E,EAAQ,EAAGK,IAAIA,IAGpD,IAAIhF,EAAO4E,EAAMD,GACbM,EAAajF,EAAKmB,OAClB+D,EAAY,SACZC,EAAM,EACNC,EAAmBF,EAAU/D,OAqBjC,IAlBgB,WAAZnB,EAAK,KACPmF,EAAM,EACNC,GAAoB,IAIpBH,EAAaG,GACbpF,EAAKiC,QAAQiD,KAAe,EAAEC,GAC9BF,EAAaG,GACc,MAA3BpF,EAAKoF,IACsB,OAA3BpF,EAAKoF,KAEL/E,EAAI,4DAGNsE,IAGwB,IAAlBC,EAAMD,SAAoClE,GAAlBmE,EAAMD,IAAuB,CAEzD,GADAtE,EAAI,uCACiC,GAAlCuE,EAAMD,GAAS1C,QAAQ,UAAc,CACtC4C,GAAmB,EACnB,MAEFF,IAIF,UAAwBlE,GAAlBmE,EAAMD,IAAuB,CAEjC,IADA,IAAIpD,GACGsD,GAAsC,IAAlBD,EAAMD,IAC/BA,IAEF,IAAIE,QAAsCpE,GAAlBmE,EAAMD,GAC5B,MAGFpD,EAAM,CACJ8D,GAAG,GACH5D,UAAU,EACVC,QAAQ,EACR4D,aAAY,EACZhD,UAAU,aACVC,aAAY,EACZC,aAAa,OACbC,aAAa,GACbC,KAAK,IACLG,UAAU,SACV0C,KAAK,GACLC,KAAK,MAGP,IAAIC,GAAe,EAEnB,IAAqC,GAAlCb,EAAMD,GAAS1C,QAAQ,UAAc,CAOtC,GANAV,EAAI8D,GAAKT,EAAMD,GAMZ,iBAAiBjE,KAAKa,EAAI8D,IAAK,CAEhC,IADAV,IACwB,IAAlBC,EAAMD,SAAoClE,GAAlBmE,EAAMD,KACG,GAAlCC,EAAMD,GAAS1C,QAAQ,WACxB5B,EAAI,uCACNsE,IAEF,SAKF,GAAqB,IAAlBC,IAFHD,SAE6ClE,GAAlBmE,EAAMD,GAAuB,CACtDtE,EAAI,wCACJ,UAGmC,GAAlCuE,EAAMD,GAAS1C,QAAQ,YACxBwD,GAAe,EACfpF,EAAI,sDAKRwE,GAAmB,EACnB,IAAIa,EAAU,IAAI3F,EAAkC6E,EAAMD,GAAUtE,GAChEmB,EAAmB,EAIvB,GAHGsD,EAAK3D,OAAS,IACfK,EAAmBsD,EAAKA,EAAK3D,OAAO,GAAGM,YAEtCgE,GAAiBC,EAAQpE,MAAMC,EAAKC,GAAvC,CAmBA,IAHAmD,IAGwB,IAAlBC,EAAMD,SAAoClE,GAAlBmE,EAAMD,IAAuB,CACzD,IAAqC,GAAlCC,EAAMD,GAAS1C,QAAQ,UAAc,CACtC5B,EAAI,kCACJwE,GAAmB,EACnB,MAEa,IAAZtD,EAAIgE,OACLhE,EAAIgE,MAAQ,MACdhE,EAAIgE,MAAQX,EAAMD,GAClBA,IAIF,IAAIgB,EAAgB,IAAIzC,EAAoB3B,EAAIgE,KAAMlF,EAAK8C,GAC3D5B,EAAIiE,KAAOG,EAAcrE,MAAMC,EAAIE,UAAWF,EAAIG,SAClDoD,EAAKzC,KAAKd,QA3BR,IAJAA,EAAM,KACNoD,IAGwB,IAAlBC,EAAMD,SAAoClE,GAAlBmE,EAAMD,IAAuB,CACzD,IAAqC,GAAlCC,EAAMD,GAAS1C,QAAQ,UAAc,CACtC4C,GAAmB,EACnB,MAEFF,KAoCN,OAZAG,EAAKc,MAAK,SAASC,EAAGC,GACpB,OAAID,EAAEpE,UAAYqE,EAAErE,WACV,EACNoE,EAAEpE,UAAYqE,EAAErE,UACX,EACLoE,EAAEnE,QAAUoE,EAAEpE,SACR,EACNmE,EAAEnE,QAAUoE,EAAEpE,QACT,EACF,KAGF,CAACoD,KAAKA,EAAMC,OAAOA,EAAQgB,KAAKtB,KAAKC,MAAMjD","file":"static/js/webvtt.eaee702f.chunk.js","sourcesContent":["// Any copyright is dedicated to the Public Domain.\n// http://creativecommons.org/publicdomain/zero/1.0/\n\n// Not intended to be fast, but if you can make it faster, please help out!\n\nvar WebVTTParser = function() {\n  this.parse = function(input, mode) {\n    //XXX need global search and replace for \\0\n    var NEWLINE = /\\r\\n|\\r|\\n/,\n        startTime = Date.now(),\n        linePos = 0,\n        lines = input.split(NEWLINE),\n        alreadyCollected = false,\n        cues = [],\n        errors = []\n    function err(message, col) {\n      errors.push({message:message, line:linePos+1, col:col})\n    }\n\n    var line = lines[linePos],\n        lineLength = line.length,\n        signature = \"WEBVTT\",\n        bom = 0,\n        signature_length = signature.length\n\n    /* Byte order mark */\n    if (line[0] === \"\\ufeff\") {\n      bom = 1\n      signature_length += 1\n    }\n    /* SIGNATURE */\n    if (\n      lineLength < signature_length ||\n      line.indexOf(signature) !== 0+bom ||\n      lineLength > signature_length &&\n      line[signature_length] !== \" \" &&\n      line[signature_length] !== \"\\t\"\n    ) {\n      err(\"No valid signature. (File needs to start with \\\"WEBVTT\\\".)\")\n    }\n\n    linePos++\n\n    /* HEADER */\n    while(lines[linePos] != \"\" && lines[linePos] != undefined) {\n      err(\"No blank line after the signature.\")\n      if(lines[linePos].indexOf(\"-->\") != -1) {\n        alreadyCollected = true\n        break\n      }\n      linePos++\n    }\n\n    /* CUE LOOP */\n    while(lines[linePos] != undefined) {\n      var cue\n      while(!alreadyCollected && lines[linePos] == \"\") {\n        linePos++\n      }\n      if(!alreadyCollected && lines[linePos] == undefined)\n        break\n\n      /* CUE CREATION */\n      cue = {\n        id:\"\",\n        startTime:0,\n        endTime:0,\n        pauseOnExit:false,\n        direction:\"horizontal\",\n        snapToLines:true,\n        linePosition:\"auto\",\n        textPosition:50,\n        size:100,\n        alignment:\"middle\",\n        text:\"\",\n        tree:null\n      }\n\n      var parseTimings = true\n\n      if(lines[linePos].indexOf(\"-->\") == -1) {\n        cue.id = lines[linePos]\n\n        /* COMMENTS\n           Not part of the specification's parser as these would just be ignored. However,\n           we want them to be conforming and not get \"Cue identifier cannot be standalone\".\n         */\n        if(/^NOTE($|[ \\t])/.test(cue.id)) { // .startsWith fails in Chrome\n          linePos++\n          while(lines[linePos] != \"\" && lines[linePos] != undefined) {\n            if(lines[linePos].indexOf(\"-->\") != -1)\n              err(\"Cannot have timestamp in a comment.\")\n            linePos++\n          }\n          continue\n        }\n\n        linePos++\n\n        if(lines[linePos] == \"\" || lines[linePos] == undefined) {\n          err(\"Cue identifier cannot be standalone.\")\n          continue\n        }\n\n        if(lines[linePos].indexOf(\"-->\") == -1) {\n          parseTimings = false\n          err(\"Cue identifier needs to be followed by timestamp.\")\n        }\n      }\n\n      /* TIMINGS */\n      alreadyCollected = false\n      var timings = new WebVTTCueTimingsAndSettingsParser(lines[linePos], err)\n      var previousCueStart = 0\n      if(cues.length > 0) {\n        previousCueStart = cues[cues.length-1].startTime\n      }\n      if(parseTimings && !timings.parse(cue, previousCueStart)) {\n        /* BAD CUE */\n\n        cue = null\n        linePos++\n\n        /* BAD CUE LOOP */\n        while(lines[linePos] != \"\" && lines[linePos] != undefined) {\n          if(lines[linePos].indexOf(\"-->\") != -1) {\n            alreadyCollected = true\n            break\n          }\n          linePos++\n        }\n        continue\n      }\n      linePos++\n\n      /* CUE TEXT LOOP */\n      while(lines[linePos] != \"\" && lines[linePos] != undefined) {\n        if(lines[linePos].indexOf(\"-->\") != -1) {\n          err(\"Blank line missing before cue.\")\n          alreadyCollected = true\n          break\n        }\n        if(cue.text != \"\")\n          cue.text += \"\\n\"\n        cue.text += lines[linePos]\n        linePos++\n      }\n\n      /* CUE TEXT PROCESSING */\n      var cuetextparser = new WebVTTCueTextParser(cue.text, err, mode)\n      cue.tree = cuetextparser.parse(cue.startTime, cue.endTime)\n      cues.push(cue)\n    }\n    cues.sort(function(a, b) {\n      if (a.startTime < b.startTime)\n        return -1\n      if (a.startTime > b.startTime)\n        return 1\n      if (a.endTime > b.endTime)\n        return -1\n      if (a.endTime < b.endTime)\n        return 1\n      return 0\n    })\n    /* END */\n    return {cues:cues, errors:errors, time:Date.now()-startTime}\n  }\n}\n\nvar WebVTTCueTimingsAndSettingsParser = function(line, errorHandler) {\n  var SPACE = /[\\u0020\\t\\f]/,\n      NOSPACE = /[^\\u0020\\t\\f]/,\n      line = line,\n      pos = 0,\n      err = function(message) {\n        errorHandler(message, pos+1)\n      },\n      spaceBeforeSetting = true\n  function skip(pattern) {\n    while(\n      line[pos] != undefined &&\n      pattern.test(line[pos])\n    ) {\n      pos++\n    }\n  }\n  function collect(pattern) {\n    var str = \"\"\n    while(\n      line[pos] != undefined &&\n      pattern.test(line[pos])\n    ) {\n      str += line[pos]\n      pos++\n    }\n    return str\n  }\n  /* http://dev.w3.org/html5/webvtt/#collect-a-webvtt-timestamp */\n  function timestamp() {\n    var units = \"minutes\",\n        val1,\n        val2,\n        val3,\n        val4\n    // 3\n    if(line[pos] == undefined) {\n      err(\"No timestamp found.\")\n      return\n    }\n    // 4\n    if(!/\\d/.test(line[pos])) {\n      err(\"Timestamp must start with a character in the range 0-9.\")\n      return\n    }\n    // 5-7\n    val1 = collect(/\\d/)\n    if(val1.length > 2 || parseInt(val1, 10) > 59) {\n      units = \"hours\"\n    }\n    // 8\n    if(line[pos] != \":\") {\n      err(\"No time unit separator found.\")\n      return\n    }\n    pos++\n    // 9-11\n    val2 = collect(/\\d/)\n    if(val2.length != 2) {\n      err(\"Must be exactly two digits.\")\n      return\n    }\n    // 12\n    if(units == \"hours\" || line[pos] == \":\") {\n      if(line[pos] != \":\") {\n        err(\"No seconds found or minutes is greater than 59.\")\n        return\n      }\n      pos++\n      val3 = collect(/\\d/)\n      if(val3.length != 2) {\n        err(\"Must be exactly two digits.\")\n        return\n      }\n    } else {\n      val3 = val2\n      val2 = val1\n      val1 = \"0\"\n    }\n    // 13\n    if(line[pos] != \".\") {\n      err(\"No decimal separator (\\\".\\\") found.\")\n      return\n    }\n    pos++\n    // 14-16\n    val4 = collect(/\\d/)\n    if(val4.length != 3) {\n      err(\"Milliseconds must be given in three digits.\")\n      return\n    }\n    // 17\n    if(parseInt(val2, 10) > 59) {\n      err(\"You cannot have more than 59 minutes.\")\n      return\n    }\n    if(parseInt(val3, 10) > 59) {\n      err(\"You cannot have more than 59 seconds.\")\n      return\n    }\n    return parseInt(val1, 10) * 60 * 60 + parseInt(val2, 10) * 60 + parseInt(val3, 10) + parseInt(val4, 10) / 1000\n  }\n\n  /* http://dev.w3.org/html5/webvtt/#parse-the-webvtt-settings */\n  function parseSettings(input, cue) {\n    var settings = input.split(SPACE),\n        seen = []\n    for(var i=0; i < settings.length; i++) {\n      if(settings[i] == \"\")\n        continue\n\n      var index = settings[i].indexOf(':'),\n          setting = settings[i].slice(0, index)\n          value = settings[i].slice(index + 1)\n\n      if(seen.indexOf(setting) != -1) {\n        err(\"Duplicate setting.\")\n      }\n      seen.push(setting)\n\n      if(value == \"\") {\n        err(\"No value for setting defined.\")\n        return\n      }\n\n      if(setting == \"vertical\") { // writing direction\n        if(value != \"rl\" && value != \"lr\") {\n          err(\"Writing direction can only be set to 'rl' or 'rl'.\")\n          continue\n        }\n        cue.direction = value\n      } else if(setting == \"line\") { // line position\n        if(!/\\d/.test(value)) {\n          err(\"Line position takes a number or percentage.\")\n          continue\n        }\n        if(value.indexOf(\"-\", 1) != -1) {\n          err(\"Line position can only have '-' at the start.\")\n          continue\n        }\n        if(value.indexOf(\"%\") != -1 && value.indexOf(\"%\") != value.length-1) {\n          err(\"Line position can only have '%' at the end.\")\n          continue\n        }\n        if(value[0] == \"-\" && value[value.length-1] == \"%\") {\n          err(\"Line position cannot be a negative percentage.\")\n          continue\n        }\n        if(value[value.length-1] == \"%\") {\n          if(parseInt(value, 10) > 100) {\n            err(\"Line position cannot be >100%.\")\n            continue\n          }\n          cue.snapToLines = false\n        }\n        cue.linePosition = parseInt(value, 10)\n      } else if(setting == \"position\") { // text position\n        if(value[value.length-1] != \"%\") {\n          err(\"Text position must be a percentage.\")\n          continue\n        }\n        if(parseInt(value, 10) > 100) {\n          err(\"Size cannot be >100%.\")\n          continue\n        }\n        cue.textPosition = parseInt(value, 10)\n      } else if(setting == \"size\") { // size\n        if(value[value.length-1] != \"%\") {\n          err(\"Size must be a percentage.\")\n          continue\n        }\n        if(parseInt(value, 10) > 100) {\n          err(\"Size cannot be >100%.\")\n          continue\n        }\n        cue.size = parseInt(value, 10)\n      } else if(setting == \"align\") { // alignment\n        var alignValues = [\"start\", \"middle\", \"end\", \"left\", \"right\"]\n        if(alignValues.indexOf(value) == -1) {\n          err(\"Alignment can only be set to one of \" + alignValues.join(\", \") + \".\")\n          continue\n        }\n        cue.alignment = value\n      } else {\n        err(\"Invalid setting.\")\n      }\n    }\n  }\n\n  this.parse = function(cue, previousCueStart) {\n    skip(SPACE)\n    cue.startTime = timestamp()\n    if(cue.startTime == undefined) {\n      return\n    }\n    if(cue.startTime < previousCueStart) {\n      err(\"Start timestamp is not greater than or equal to start timestamp of previous cue.\")\n    }\n    if(NOSPACE.test(line[pos])) {\n      err(\"Timestamp not separated from '-->' by whitespace.\")\n    }\n    skip(SPACE)\n    // 6-8\n    if(line[pos] != \"-\") {\n      err(\"No valid timestamp separator found.\")\n      return\n    }\n    pos++\n    if(line[pos] != \"-\") {\n      err(\"No valid timestamp separator found.\")\n      return\n    }\n    pos++\n    if(line[pos] != \">\") {\n      err(\"No valid timestamp separator found.\")\n      return\n    }\n    pos++\n    if(NOSPACE.test(line[pos])) {\n      err(\"'-->' not separated from timestamp by whitespace.\")\n    }\n    skip(SPACE)\n    cue.endTime = timestamp()\n    if(cue.endTime == undefined) {\n      return\n    }\n    if(cue.endTime <= cue.startTime) {\n      err(\"End timestamp is not greater than start timestamp.\")\n    }\n\n    if(NOSPACE.test(line[pos])) {\n      spaceBeforeSetting = false\n    }\n    skip(SPACE)\n    parseSettings(line.substring(pos), cue)\n    return true\n  }\n  this.parseTimestamp = function() {\n    var ts = timestamp()\n    if(line[pos] != undefined) {\n      err(\"Timestamp must not have trailing characters.\")\n      return\n    }\n    return ts\n  }\n}\n\nvar WebVTTCueTextParser = function(line, errorHandler, mode) {\n  var line = line,\n      pos = 0,\n      err = function(message) {\n        if(mode == \"metadata\")\n          return\n        errorHandler(message, pos+1)\n      }\n\n  this.parse = function(cueStart, cueEnd) {\n    var result = {children:[]},\n        current = result,\n        timestamps = []\n\n    function attach(token) {\n      current.children.push({type:\"object\", name:token[1], classes:token[2], children:[], parent:current})\n      current = current.children[current.children.length-1]\n    }\n    function inScope(name) {\n      var node = current\n      while(node) {\n        if(node.name == name)\n          return true\n        node = node.parent\n      }\n      return\n    }\n\n    while(line[pos] != undefined) {\n      var token = nextToken()\n      if(token[0] == \"text\") {\n        current.children.push({type:\"text\", value:token[1], parent:current})\n      } else if(token[0] == \"start tag\") {\n        if(mode == \"chapters\")\n          err(\"Start tags not allowed in chapter title text.\")\n        var name = token[1]\n        if(name != \"v\" && name != \"lang\" && token[3] != \"\") {\n          err(\"Only <v> and <lang> can have an annotation.\")\n        }\n        if(\n          name == \"c\" ||\n          name == \"i\" ||\n          name == \"b\" ||\n          name == \"u\" ||\n          name == \"ruby\"\n        ) {\n          attach(token)\n        } else if(name == \"rt\" && current.name == \"ruby\") {\n          attach(token)\n        } else if(name == \"v\") {\n          if(inScope(\"v\")) {\n            err(\"<v> cannot be nested inside itself.\")\n          }\n          attach(token)\n          current.value = token[3] // annotation\n          if(!token[3]) {\n            err(\"<v> requires an annotation.\")\n          }\n        } else if(name == \"lang\") {\n          attach(token)\n          current.value = token[3] // language\n        } else {\n          err(\"Incorrect start tag.\")\n        }\n      } else if(token[0] == \"end tag\") {\n        if(mode == \"chapters\")\n          err(\"End tags not allowed in chapter title text.\")\n        // XXX check <ruby> content\n        if(token[1] == current.name) {\n          current = current.parent\n        } else if(token[1] == \"ruby\" && current.name == \"rt\") {\n          current = current.parent.parent\n        } else {\n          err(\"Incorrect end tag.\")\n        }\n      } else if(token[0] == \"timestamp\") {\n        if(mode == \"chapters\")\n          err(\"Timestamp not allowed in chapter title text.\")\n        var timings = new WebVTTCueTimingsAndSettingsParser(token[1], err),\n            timestamp = timings.parseTimestamp()\n        if(timestamp != undefined) {\n          if(timestamp <= cueStart || timestamp >= cueEnd) {\n            err(\"Timestamp must be between start timestamp and end timestamp.\")\n          }\n          if(timestamps.length > 0 && timestamps[timestamps.length-1] >= timestamp) {\n            err(\"Timestamp must be greater than any previous timestamp.\")\n          }\n          current.children.push({type:\"timestamp\", value:timestamp, parent:current})\n          timestamps.push(timestamp)\n        }\n      }\n    }\n    while(current.parent) {\n      if(current.name != \"v\") {\n        err(\"Required end tag missing.\")\n      }\n      current = current.parent\n    }\n    return result\n  }\n\n  function nextToken() {\n    var state = \"data\",\n        result = \"\",\n        buffer = \"\",\n        classes = []\n    while(line[pos-1] != undefined || pos == 0) {\n      var c = line[pos]\n      if(state == \"data\") {\n        if(c == \"&\") {\n          buffer = c\n          state = \"escape\"\n        } else if(c == \"<\" && result == \"\") {\n          state = \"tag\"\n        } else if(c == \"<\" || c == undefined) {\n          return [\"text\", result]\n        } else {\n          result += c\n        }\n      } else if(state == \"escape\") {\n        if(c == \"&\") {\n          err(\"Incorrect escape.\")\n          result += buffer\n          buffer = c\n        } else if(/[abglmnsprt]/.test(c)) {\n          buffer += c\n        } else if(c == \";\") {\n          if(buffer == \"&amp\") {\n            result += \"&\"\n          } else if(buffer == \"&lt\") {\n            result += \"<\"\n          } else if(buffer == \"&gt\") {\n            result += \">\"\n          } else if(buffer == \"&lrm\") {\n            result += \"\\u200e\"\n          } else if(buffer == \"&rlm\") {\n            result += \"\\u200f\"\n          } else if(buffer == \"&nbsp\") {\n            result += \"\\u00A0\"\n          } else {\n            err(\"Incorrect escape.\")\n            result += buffer + \";\"\n          }\n          state = \"data\"\n        } else if(c == \"<\" || c == undefined) {\n          err(\"Incorrect escape.\")\n          result += buffer\n          return [\"text\", result]\n        } else {\n          err(\"Incorrect escape.\")\n          result += buffer + c\n          state = \"data\"\n        }\n      } else if(state == \"tag\") {\n        if(c == \"\\t\" || c == \"\\n\" || c == \"\\f\" || c == \" \") {\n          state = \"start tag annotation\"\n        } else if(c == \".\") {\n          state = \"start tag class\"\n        } else if(c == \"/\") {\n          state = \"end tag\"\n        } else if(/\\d/.test(c)) {\n          result = c\n          state = \"timestamp tag\"\n        } else if(c == \">\" || c == undefined) {\n          if(c == \">\") {\n            pos++\n          }\n          return [\"start tag\", \"\", [], \"\"]\n        } else {\n          result = c\n          state = \"start tag\"\n        }\n      } else if(state == \"start tag\") {\n        if(c == \"\\t\" || c == \"\\f\" || c == \" \") {\n          state = \"start tag annotation\"\n        } else if(c == \"\\n\") {\n          buffer = c\n          state = \"start tag annotation\"\n        } else if(c == \".\") {\n          state = \"start tag class\"\n        } else if(c == \">\" || c == undefined) {\n          if(c == \">\") {\n            pos++\n          }\n          return [\"start tag\", result, [], \"\"]\n        } else {\n          result += c\n        }\n      } else if(state == \"start tag class\") {\n        if(c == \"\\t\" || c == \"\\f\" || c == \" \") {\n          classes.push(buffer)\n          buffer = \"\"\n          state = \"start tag annotation\"\n        } else if(c == \"\\n\") {\n          classes.push(buffer)\n          buffer = c\n          state = \"start tag annotation\"\n        } else if(c == \".\") {\n          classes.push(buffer)\n          buffer = \"\"\n        } else if(c == \">\" || c == undefined) {\n          if(c == \">\") {\n            pos++\n          }\n          classes.push(buffer)\n          return [\"start tag\", result, classes, \"\"]\n        } else {\n          buffer += c\n        }\n      } else if(state == \"start tag annotation\") {\n        if(c == \">\" || c == undefined) {\n          if(c == \">\") {\n            pos++\n          }\n          buffer = buffer.split(/[\\u0020\\t\\f\\r\\n]+/).filter(function(item) { if(item) return true }).join(\" \")\n          return [\"start tag\", result, classes, buffer]\n        } else {\n          buffer +=c\n        }\n      } else if(state == \"end tag\") {\n        if(c == \">\" || c == undefined) {\n          if(c == \">\") {\n            pos++\n          }\n          return [\"end tag\", result]\n        } else {\n          result += c\n        }\n      } else if(state == \"timestamp tag\") {\n        if(c == \">\" || c == undefined) {\n          if(c == \">\") {\n            pos++\n          }\n          return [\"timestamp\", result]\n        } else {\n          result += c\n        }\n      } else {\n        err(\"Never happens.\") // The joke is it might.\n      }\n      // 8\n      pos++\n    }\n  }\n}\n\nvar WebVTTSerializer = function() {\n  function serializeTree(tree) {\n    var result = \"\"\n    for (var i = 0; i < tree.length; i++) {\n      var node = tree[i]\n      if(node.type == \"text\") {\n        result += node.value\n      } else if(node.type == \"object\") {\n        result += \"<\" + node.name\n        if(node.classes) {\n          for(var y = 0; y < node.classes.length; y++) {\n            result += \".\" + node.classes[y]\n          }\n        }\n        if(node.value) {\n          result += \" \" + node.value\n        }\n        result += \">\"\n        if(node.children)\n          result += serializeTree(node.children)\n        result += \"</\" + node.name + \">\"\n      } else {\n        result += \"<\" + node.value + \">\"\n      }\n    }\n    return result\n  }\n  function serializeCue(cue) {\n    return cue.startTime + \" \" + cue.endTime + \"\\n\" + serializeTree(cue.tree.children) + \"\\n\\n\"\n  }\n  this.serialize = function(cues) {\n    var result = \"\"\n    for(var i=0;i<cues.length;i++) {\n      result += serializeCue(cues[i])\n    }\n    return result\n  }\n}\n\nexport default WebVTTParser;\n"],"sourceRoot":""}